#ifndef COOKLANG_H
#define COOKLANG_H

/* Generated with cbindgen:0.24.5 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#define COOK_EXT_MULTILINE_STEPS (1 << 0)

#define COOK_EXT_COMPONENT_MODIFIERS (1 << 1)

#define COOK_EXT_COMPONENT_NOTE (1 << 2)

#define COOK_EXT_COMPONENT_ALIAS (1 << 3)

#define COOK_EXT_SECTIONS (1 << 4)

#define COOK_EXT_ADVANCED_UNITS (1 << 5)

#define COOK_EXT_MODES (1 << 6)

#define COOK_EXT_TEMPERATURE (1 << 7)

#define COOK_EXT_TEXT_STEPS (1 << 8)

#define COOK_EXT_RANGE_VALUES (1 << 9)

typedef enum ComponentKind {
  ComponentKind_Ingredient,
  ComponentKind_Cookware,
  ComponentKind_Timer,
} ComponentKind;

typedef enum CookErrorCode {
  COOK_ERROR_CODE_NONE = 0,
  COOK_ERROR_CODE_NON_UTF8,
  COOK_ERROR_CODE_IO_ERROR,
  COOK_ERROR_CODE_PARSE_UNITS_FILE,
  COOK_ERROR_CODE_CONVERTER_BUILDER,
} CookErrorCode;

typedef struct CookAst CookAst;

typedef struct CookParser CookParser;

typedef struct CookError CookError;

typedef struct CookMetadata CookMetadata;

typedef struct ParseResult ParseResult;

typedef struct CookRecipe CookRecipe;

typedef const char *CCString;

/**
 * A component reference
 */
typedef struct Component {
  /**
   * What kind of component is
   */
  enum ComponentKind kind;
  /**
   * The index in the corresponding [Vec] in the [Recipe] struct.
   */
  size_t index;
} Component;

typedef enum Item_Tag {
  /**
   * Just plain text
   */
  Item_Text,
  /**
   * A [Component]
   */
  Item_Component,
  /**
   * An inline quantity.
   *
   * The number inside is an index into [Recipe::inline_quantities].
   */
  Item_InlineQuantity,
} Item_Tag;

typedef struct Item {
  Item_Tag tag;
  union {
    struct {
      const char *text;
    };
    struct {
      struct Component component;
    };
    struct {
      size_t inline_quantity;
    };
  };
} Item;

typedef struct Step {
  const struct Item *items;
  size_t items_len;
  bool is_text;
} Step;

typedef struct Section {
  CCString name;
  const struct Step *steps;
  size_t steps_len;
} Section;

typedef enum Value_Tag {
  /**
   * Numeric
   */
  Value_Number,
  /**
   * Range
   */
  Value_Range,
  /**
   * Text
   *
   * It is not possible to operate with this variant.
   */
  Value_Text,
} Value_Tag;

typedef struct Value_Range_Body {
  double from;
  double to;
} Value_Range_Body;

typedef struct Value {
  Value_Tag tag;
  union {
    struct {
      double number;
    };
    Value_Range_Body range;
    struct {
      CCString text;
    };
  };
} Value;

typedef enum QuantityValue_Tag {
  /**
   * Cannot be scaled
   */
  QuantityValue_Fixed,
  /**
   * Scaling is linear to the number of servings
   */
  QuantityValue_Linear,
  /**
   * Scaling is in defined steps of the number of servings
   */
  QuantityValue_ByServings,
} QuantityValue_Tag;

typedef struct QuantityValue_ByServings_Body {
  const struct Value *values;
  size_t values_len;
} QuantityValue_ByServings_Body;

typedef struct QuantityValue {
  QuantityValue_Tag tag;
  union {
    struct {
      struct Value fixed;
    };
    struct {
      struct Value linear;
    };
    QuantityValue_ByServings_Body by_servings;
  };
} QuantityValue;

typedef struct Quantity {
  struct QuantityValue value;
  /**
   * nullable
   */
  const char *unit;
} Quantity;

typedef struct Ingredient {
  CCString name;
  /**
   * nullable
   */
  CCString alias;
  /**
   * nullable
   */
  const struct Quantity *quantity;
  /**
   * nullable
   */
  CCString note;
  uint32_t modifiers;
  /**
   * index to definition. -1 if this is the definition
   */
  ptrdiff_t references_to;
} Ingredient;

typedef struct Cookware {
  CCString name;
  /**
   * nullable
   */
  CCString alias;
  /**
   * nullable
   */
  const struct QuantityValue *quantity;
  /**
   * nullable
   */
  CCString note;
  uint32_t modifiers;
  /**
   * index to definition. -1 if this is the definition
   */
  ptrdiff_t references_to;
} Cookware;

typedef struct Timer {
  /**
   * nullable
   */
  CCString name;
  struct Quantity quantity;
} Timer;

typedef struct RecipeData {
  CCString name;
  const struct CookMetadata *metadata;
  const struct Section *sections;
  size_t sections_len;
  const struct Ingredient *ingredients;
  size_t ingredients_len;
  const struct Cookware *cookware;
  size_t cookware_len;
  const struct Timer *timers;
  size_t timers_len;
  const struct Quantity *inline_quantities;
  size_t inline_quantities_len;
} RecipeData;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void cooklang_print_version(void);

/**
 * Allocates space for an error.
 *
 * If error information is desired, this function should be called to create
 * a CookError pointer. Then the pointer can be passed to any function that
 * can raise an error.
 *
 * If NULL is passed to these functions, no error information will be received.
 */
struct CookError *cook_error_new(void);

/**
 * Free the error given.
 *
 * This must be called at most once.
 */
void cook_error_free(struct CookError *err);

/**
 * Get a code for the error.
 */
enum CookErrorCode cook_error_code(const struct CookError *err);

/**
 * Get an error message from the error given.
 *
 * The string will be freed when `cook_error_free` is called
 */
const char *cook_error_msg(struct CookError *err);

/**
 * Creates a new parser.
 *
 * Creating the parser is not cheap, so for parsing multiple recipes it's not
 * optimal to recreate it every time.
 */
const struct CookParser *cook_parser_new(uint32_t extensions);

/**
 * Creates a new parser with custom units.
 *
 * Creating the parser is not cheap, so for parsing multiple recipes it's not
 * optimal to recreate it every time.
 *
 * Adding custom units can fail.
 */
const struct CookParser *cook_parser_new_with_converter(uint32_t extensions,
                                                        const char *const *units_files,
                                                        size_t units_files_len,
                                                        struct CookError *error);

/**
 * Free the given parser.
 *
 * This must be called at most once.
 */
void cook_parser_free(const struct CookParser *parser);

/**
 * Parse a recipe.
 *
 * The `error` param is for fatal errors like when the input is not utf-8,
 * not parsing errors of bad syntax.
 *
 * The result must be freed with `cook_result_free`.
 */
const struct ParseResult *cook_parse(const struct CookParser *parser,
                                     const char *input,
                                     const char *recipe_name,
                                     struct CookError *error);

/**
 * Parse a recipe, only metadata.
 *
 * The `error` param is for fatal errors like when the input is not utf-8,
 * not parsing errors of bad syntax.
 *
 * The result must be freed with `cook_result_free`.
 */
const struct ParseResult *cook_parse_metadata(const struct CookParser *parser,
                                              const char *input,
                                              struct CookError *error);

/**
 * Parse a recipe into an AST, no analysis
 *
 * The `error` param is for fatal errors like when the input is not utf-8,
 * not parsing errors of bad syntax.
 */
const struct ParseResult *cook_parse_ast(const char *input,
                                         uint32_t extensions,
                                         struct CookError *error);

/**
 * Get a value for a key from the metadata dict.
 *
 * The returned string is valid until this function is called again or
 * the metadata pointer is freed.
 *
 * Returns NULL if not found.
 */
const char *cook_metadata_get(const struct CookMetadata *metadata, const char *key);

void cook_recipe_scale(struct CookRecipe **recipe,
                       uint32_t target,
                       const struct CookParser *parser);

void cook_recipe_default_scale(struct CookRecipe **recipe);

void cook_recipe_free(const struct CookRecipe *recipe);

/**
 * Gets the data of the inner recipe.
 *
 * Once the data is extracted, the recipe obtained from the result can be freed
 * and this will be valid until `cooklang_recipe_data_free` is called.
 *
 * This recipe cannot be converted or scaled. Do that before getting the data.
 */
const struct RecipeData *cook_recipe_data(struct CookRecipe *recipe);

void cook_recipe_data_free(const struct RecipeData *recipe);

/**
 * Free the resources of the result object.
 */
void cook_result_free(struct ParseResult *result);

/**
 * Checks if the result is valid and contains some output
 */
bool cook_result_is_valid(const struct ParseResult *result);

/**
 * Get the inner Recipe value
 *
 * If there is no value, returns NULL.
 *
 * This can only be done once. Further calls will return null.
 *
 * If the result was not created with `cook_parse` this will panic.
 */
const struct CookRecipe *cook_result_get_recipe(struct ParseResult *result);

/**
 * Get the inner Metadata value
 *
 * If there is no value, returns NULL.
 *
 * If the result was not created with `cook_parse_metadata` this will panic.
 */
const struct CookMetadata *cook_result_get_metadata(const struct ParseResult *result);

/**
 * Get the inner AST value
 *
 * If there is no value, returns NULL.
 *
 * If the result was not created with `cook_parse_ast` this will panic.
 */
const struct CookAst *cook_result_get_ast(const struct ParseResult *result);

/**
 * Generates a fancy report string.
 *
 * It may contain warnings and/or errors.
 *
 * If no warnings or errors exists, NULL will be returned.
 */
const char *cook_result_fancy_report(struct ParseResult *result,
                                     const char *file_name,
                                     const char *source_code,
                                     bool hide_warnings,
                                     struct CookError *error);

/**
 * Prints a fancy report to stdout
 */
void cook_result_print(const struct ParseResult *result,
                       const char *file_name,
                       const char *source_code,
                       bool hide_warnings,
                       struct CookError *error);

/**
 * Prints a fancy report to stderr
 */
void cook_result_eprint(const struct ParseResult *result,
                        const char *file_name,
                        const char *source_code,
                        bool hide_warnings,
                        struct CookError *error);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* COOKLANG_H */
