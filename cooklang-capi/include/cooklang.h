#ifndef COOKLANG_H
#define COOKLANG_H

/* Generated with cbindgen:0.24.3 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#define COOK_EXT_MULTILINE_STEPS (1 << 0)

#define COOK_EXT_COMPONENT_MODIFIERS (1 << 1)

#define COOK_EXT_COMPONENT_NOTE (1 << 2)

#define COOK_EXT_COMPONENT_ALIAS (1 << 3)

#define COOK_EXT_SECTIONS (1 << 4)

#define COOK_EXT_ADVANCED_UNITS (1 << 5)

#define COOK_EXT_MODES (1 << 6)

#define COOK_EXT_TEMPERATURE (1 << 7)

#define COOK_EXT_TEXT_STEPS (1 << 8)

#define COOK_EXT_RANGE_VALUES (1 << 9)

typedef enum cook_error_code {
  NONE = 0,
  NON_UTF8,
  IO_ERROR,
  PARSE_UNITS_FILE,
  CONVERTER_BUILDER,
} cook_error_code;

typedef struct CookAst CookAst;

typedef struct CookParser CookParser;

typedef struct CookError CookError;

typedef struct CookMetadata CookMetadata;

typedef struct ParseResult ParseResult;

typedef struct CookRecipe CookRecipe;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Allocates space for an error.
 *
 * If error information is desired, this function should be called to create
 * a CookError pointer. Then the pointer can be passed to any function that
 * can raise an error.
 *
 * If NULL is passed to these functions, no error information will be received.
 */
struct CookError *cook_error_new(void);

/**
 * Free the error given.
 *
 * This must be called at most once.
 */
void cook_error_free(struct CookError *err);

/**
 * Get a code for the error.
 */
enum cook_error_code cook_error_get_code(const struct CookError *err);

/**
 * Get an error message from the error given.
 *
 * The string will be freed when `cook_error_free` is called
 */
const char *cook_error_msg(struct CookError *err);

/**
 * Creates a new parser.
 *
 * Creating the parser is not cheap, so for parsing multiple recipes it's not
 * optimal to recreate it every time.
 */
const struct CookParser *cook_parser_new(uint32_t extensions);

/**
 * Creates a new parser with custom units.
 *
 * Creating the parser is not cheap, so for parsing multiple recipes it's not
 * optimal to recreate it every time.
 *
 * Adding custom units can fail.
 */
const struct CookParser *cook_parser_new_with_converter(uint32_t extensions,
                                                        const char *const *units_files,
                                                        size_t units_files_len,
                                                        struct CookError *error);

/**
 * Free the given parser.
 *
 * This must be called at most once.
 */
void cook_parser_free(const struct CookParser *parser);

/**
 * Parse a recipe.
 *
 * The `error` param is for fatal errors like when the input is not utf-8,
 * not parsing errors of bad syntax.
 *
 * The result must be freed with `cook_result_free`.
 */
const struct ParseResult *cook_parse(const struct CookParser *parser,
                                     const char *input,
                                     const char *recipe_name,
                                     struct CookError *error);

/**
 * Parse a recipe, only metadata.
 *
 * The `error` param is for fatal errors like when the input is not utf-8,
 * not parsing errors of bad syntax.
 *
 * The result must be freed with `cook_result_free`.
 */
const struct ParseResult *cook_parse_metadata(const struct CookParser *parser,
                                              const char *input,
                                              struct CookError *error);

/**
 * Parse a recipe into an AST, no analysis
 *
 * The `error` param is for fatal errors like when the input is not utf-8,
 * not parsing errors of bad syntax.
 */
const struct ParseResult *cook_parse_ast(const char *input,
                                         uint32_t extensions,
                                         struct CookError *error);

/**
 * Free the resources of the result object.
 */
void cook_result_free(struct ParseResult *result);

/**
 * Checks if the result is valid and contains some output
 */
bool cook_result_is_valid(const struct ParseResult *result);

/**
 * Get the inner Recipe value
 *
 * If there is no value, returns NULL.
 *
 * If the result was not created with `cook_parse` this will panic.
 */
const struct CookRecipe *cook_result_get_recipe(const struct ParseResult *result);

/**
 * Get the inner Metadata value
 *
 * If there is no value, returns NULL.
 *
 * If the result was not created with `cook_parse_metadata` this will panic.
 */
const struct CookMetadata *cook_result_get_metadata(const struct ParseResult *result);

/**
 * Get the inner AST value
 *
 * If there is no value, returns NULL.
 *
 * If the result was not created with `cook_parse_ast` this will panic.
 */
const struct CookAst *cook_result_get_ast(const struct ParseResult *result);

/**
 * Generates a fancy report string.
 *
 * It may contain warnings and/or errors.
 *
 * If no warnings or errors exists, NULL will be returned.
 */
const char *cook_result_fancy_report(struct ParseResult *result,
                                     const char *file_name,
                                     const char *source_code,
                                     bool hide_warnings,
                                     struct CookError *error);

/**
 * Prints a fancy report to stdout
 */
void cook_result_print(const struct ParseResult *result,
                       const char *file_name,
                       const char *source_code,
                       bool hide_warnings,
                       struct CookError *error);

/**
 * Prints a fancy report to stderr
 */
void cook_result_eprint(const struct ParseResult *result,
                        const char *file_name,
                        const char *source_code,
                        bool hide_warnings,
                        struct CookError *error);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* COOKLANG_H */
